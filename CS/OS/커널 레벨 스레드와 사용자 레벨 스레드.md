# 커널 레벨 스레드와 사용자 레벨 스레드

## 커널 레벨 스레드

- 가장 가벼운 커널 스케줄링 단위
- 하나의 프로세스는 적어도 하나의 커널 스레드를 가진다.
- 커널 영역에서 스레드 연산 수행
- 커널이 스레드를 관리하므로 커널 종속적
- 프로그래머 요청에 따라 스레드 생성, 스케줄링 주체가 커널이면 이를 Kernel level thread라고 한다.

#### ✅ 커널 레벨 스레드의 장점

1. 프로세스의 스레드들을 몇몇 프로세서에서 한꺼번에 디스패치할 수 있기 때문에 멀티 프로세서 환경에서 매우 빠르게 동작
2. 다른 스레드의 입출력 작업이 다 끝날 때까지 다른 스레드를 사용해 다른 작업을 수행할 수 있다.
3. 커널이 각 스레드를 개별적으로 관리할 수 있다.
4. 커널이 직접 스레드를 제공하기 때문에 안정성과 다양한 기능 제공

#### ✅ 커널 레벨 스레드의 단점

1. 스케줄링과 동기화를 위해 커널을 호출하는데 저장한 내용을 다시 불러와야 하기 때문에 무겁고 오래 걸린다.
2. 즉, 사용자 모드에서 커널 모드로의 전환이 빈번하게 이뤄지는 경우 성능 저하 발생
3. 사용자가 프로그래밍 할 때 구현하기 어렵고 자원 소비가 많다.


## 사용자 레벨 스레드

- 커널 영역의 상위에서 지원되며 사용자 레벨의 라이브러리를 통해 구현된다.
- 사용자 영역에서 스레드 연산을 수행한다. 이 때문에 운영체제에 종속되지 않는다.
- 커널에 의존적이지 않은 형태로 스레드의 기능ㅇㄹ 제공하는 라이브러리를 활용하는 방식이 user level thread라고 한다.

#### ✅ 사용자 레벨 스레드의 장점

1. 운영체제에서 스레드를 지원할 필요가 없다.
2. 스케줄링 결정이나 동기화를 위해 커널을 호출하지 않기 때문에 인터럽트 발생 시, 커널 레벨 스레드보다 오버헤드가 적다.
3. 즉, 사용자 영역 스레드에서만 움직이기 때문에 context switch가 없다. <- 사용자 레벨 스레드 스케줄러 이용
4. 커널은 사용자 레벨 스레드를 모르기 때문에 모드 간의 전환이 없고 이득 발생

#### ✅ 사용자 레벨 스레드의 단점

1. 시스템 전반에 걸친 스케줄링 우선순위를 지원하지 않는다.
2. 프로세스에 속한 스레드 중 I/O 작업에 의해 하나라도 block이 걸리면 전체 스레드가 block 된다.


![image](https://user-images.githubusercontent.com/60870438/190101208-919b6015-45ef-4072-aea0-c056bc86e70e.png)

![image](https://user-images.githubusercontent.com/60870438/190125205-0d8c5a70-1785-4dae-82ae-57ff4eb0241b.png)


```
커널 레벨 스레드: 커널 내에 있는 스레드
사용자 레벨 스레드: #include <thread> 혹은 import를 통해 스레드를 이용하는 것.
```

### [방법 1] Pure user-level

- 커널 스레드 1개 당 사용자 스래드 n개를 의미한다. 1:n
- 커널은 사용자 스레드가 100개 있어도 모르기 때문에 사용자 스레드에서 I/O가 발생하면 해당 프로세스는 block된다.


### [방법 2] Pure kernel-level

- n개의 커널 스레드가 n개의 사용자 스레드를 담당하게 된다. 1:1
- 병렬성은 좋으나 효율성이 떨어진다.

### [방법 3] Conbined

- 커널 스레드와 사용자 스레드를 혼한하여 사용하는 방식.

# 참고
- [커널 레벨 스레드 vs 사용자 레벨 스레드](https://www.crocus.co.kr/1255)
